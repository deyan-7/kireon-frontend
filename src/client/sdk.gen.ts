// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from '@hey-api/client-fetch';
import type { InfoInfoGetData, InfoInfoGetResponse, InvokeInvokePostData, InvokeInvokePostResponse, InvokeInvokePostError, InvokeAgentIdInvokePostData, InvokeAgentIdInvokePostResponse, InvokeAgentIdInvokePostError, StreamStreamPostData, StreamStreamPostResponse, StreamStreamPostError, StreamAgentIdStreamPostData, StreamAgentIdStreamPostResponse, StreamAgentIdStreamPostError, FeedbackFeedbackPostData, FeedbackFeedbackPostResponse, FeedbackFeedbackPostError, HistoryHistoryPostData, HistoryHistoryPostResponse, HistoryHistoryPostError, HealthCheckHealthGetData, ReadinessReadinessGetData, ReadinessReadinessGetResponse } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Info
 */
export const infoInfoGet = <ThrowOnError extends boolean = false>(options?: Options<InfoInfoGetData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<InfoInfoGetResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/info',
        ...options
    });
};

/**
 * Invoke
 * Invoke an agent with user input to retrieve a final response.
 *
 * If agent_id is not provided, the default agent will be used.
 * Use thread_id to persist and continue a multi-turn conversation. run_id kwarg
 * is also attached to messages for recording feedback.
 * Use user_id to persist and continue a conversation across multiple threads.
 */
export const invokeInvokePost = <ThrowOnError extends boolean = false>(options: Options<InvokeInvokePostData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<InvokeInvokePostResponse, InvokeInvokePostError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/invoke',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Invoke
 * Invoke an agent with user input to retrieve a final response.
 *
 * If agent_id is not provided, the default agent will be used.
 * Use thread_id to persist and continue a multi-turn conversation. run_id kwarg
 * is also attached to messages for recording feedback.
 * Use user_id to persist and continue a conversation across multiple threads.
 */
export const invokeAgentIdInvokePost = <ThrowOnError extends boolean = false>(options: Options<InvokeAgentIdInvokePostData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<InvokeAgentIdInvokePostResponse, InvokeAgentIdInvokePostError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/{agent_id}/invoke',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Stream
 * Stream an agent's response to a user input, including intermediate messages and tokens.
 *
 * If agent_id is not provided, the default agent will be used.
 * Use thread_id to persist and continue a multi-turn conversation. run_id kwarg
 * is also attached to all messages for recording feedback.
 * Use user_id to persist and continue a conversation across multiple threads.
 *
 * Set `stream_tokens=false` to return intermediate messages but not token-by-token.
 */
export const streamStreamPost = <ThrowOnError extends boolean = false>(options: Options<StreamStreamPostData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<StreamStreamPostResponse, StreamStreamPostError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/stream',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Stream
 * Stream an agent's response to a user input, including intermediate messages and tokens.
 *
 * If agent_id is not provided, the default agent will be used.
 * Use thread_id to persist and continue a multi-turn conversation. run_id kwarg
 * is also attached to all messages for recording feedback.
 * Use user_id to persist and continue a conversation across multiple threads.
 *
 * Set `stream_tokens=false` to return intermediate messages but not token-by-token.
 */
export const streamAgentIdStreamPost = <ThrowOnError extends boolean = false>(options: Options<StreamAgentIdStreamPostData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<StreamAgentIdStreamPostResponse, StreamAgentIdStreamPostError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/{agent_id}/stream',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Feedback
 * Record feedback for a run to LangSmith.
 *
 * This is a simple wrapper for the LangSmith create_feedback API, so the
 * credentials can be stored and managed in the service rather than the client.
 * See: https://api.smith.langchain.com/redoc#tag/feedback/operation/create_feedback_api_v1_feedback_post
 */
export const feedbackFeedbackPost = <ThrowOnError extends boolean = false>(options: Options<FeedbackFeedbackPostData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<FeedbackFeedbackPostResponse, FeedbackFeedbackPostError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/feedback',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * History
 * Get chat history.
 */
export const historyHistoryPost = <ThrowOnError extends boolean = false>(options: Options<HistoryHistoryPostData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<HistoryHistoryPostResponse, HistoryHistoryPostError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/history',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Health Check
 * Health check endpoint.
 */
export const healthCheckHealthGet = <ThrowOnError extends boolean = false>(options?: Options<HealthCheckHealthGetData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<unknown, unknown, ThrowOnError>({
        url: '/health',
        ...options
    });
};

/**
 * Readiness
 * Readiness check endpoint.
 */
export const readinessReadinessGet = <ThrowOnError extends boolean = false>(options?: Options<ReadinessReadinessGetData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ReadinessReadinessGetResponse, unknown, ThrowOnError>({
        url: '/readiness',
        ...options
    });
};